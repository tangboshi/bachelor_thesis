\chapter{Measurement Methodology}
\label{ch:methodology}

This chapter describes methods and scenarios of the measurements we have taken. Firstly, the measurement testbed is discussed. Secondly, we define central terms to guard against misapprehensions. Thereafter, we give an overview of the MAC protocols we empirically evaluated, implemented as GNU Radio flowgraphs. Subsequently, measurement metrics which we use in chapter \ref{ch:results} to analyze the performance of the protocols are formally defined with reference to the flowgraphs. Thereafter, an overview of the semi-automatic measurement script system designed to automate, therefore accelerate the process of file system management, data processing and result plotting is given. Eventually, we discuss the quality norms of the measurements.

\section{Measurement Testbed}

The setup consists of two USRP2s from Ettus Research and two USRP 2920s from National Instruments. The first two USRPs are programmed as receiver and sniffer, respectively, whereas the latter two as transmitters, as depicted in \ref{fig:measurement-setup}. Each USRP was connected to a gigabit switch through a LAN cable. The scripts running on the devices were launched from a local computer with the IP 134.130.223.151, which was remotely controlled from a laptop. Both transmitters sent their data to the single receiver. Hereafter, we call the node pair 10.0.0.9-10.0.0.6 link 1 and 10.0.0.3-10.0.0.6 link 2. Tables \ref{tab:measurement-parameters} and \ref{tab:measurement-parameters-2}  contains other necessary configuration parameters to reproduce the measurement results.

\begin{figure}[tb]
	\label{fig:measurement-setup}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{pictures/measurement_setup}
	\end{center}
	\caption[Photo of the measurement setup.]{Photo of the measurement setup. The transmitters 10.0.0.3 and 10.0.0.9 transmit their data to the receiver 10.0.0.6. Their conversations are overheard by the sniffer 10.0.0.10.}
\end{figure}

% Measurement parameters
\begin{table}[t]
	\label{tab:measurement-parameters}
	\begin{center}
		\begin{tabular}{*{14}{|c}|}
			\hline
			Function & TX Gain & RX Gain & Source Address & Dest. Address & IP Address\\
			\hline
			Receiver 		& 4 dB 	& 10 dB & X 	& any	& 10.0.0.6\\
			Sniffer 		& 0 	& 0 	& any 	& any	& 10.0.0.10 \\
			Transmitter 1 	& 5 dB 	& 0 	& Y 	& 	X 	& 10.0.0.9 \\
			Transmitter 2	& 9 dB 	& 0 	& Z 	& 	X 	& 10.0.0.3 \\
			\hline	
		\end{tabular}\caption{Device-specific setup parameters.}
	\end{center}
\end{table}

\begin{table}[t]
	\label{tab:measurement-parameters-2}
	\begin{center}
		\begin{tabular}{*{14}{|c}|}
			\hline
			Layer & Parameter & Value & Comment\\
			\hline
			 			& MCS & QPSK & BPSK optional, unused\\
			PHY Layer	& Carrier frequency & 450 MHz & 420 MHz - 480 MHz work as well \\
						& Sampling rate & 400 k/s & \\
			\hline	
						& Frame size & 1000 bytes & max. supported by OS\\
						& Payload size & 837 bytes & \\
			MAC Layer	& Timeout & 100 ms & $\text{RTT \le 68 ms}$ \\
						& CSMA CS threshold & 0.001 PU & for RX/TX gains as in Table \ref{tab:measurement-parameters} \\  
						& Max. retransmissions & 6 & \\
			\hline	
		\end{tabular}\caption{General setup parameters.}
	\end{center}
\end{table}

\section{Measurement Protocols and Scenarios}
\label{sec:measurement-scenarios}

Next, we define some central terms used throughout the remainder of the thesis and then present the measurement scenarios.

\paragraph{Traffic Saturation}
If not specified otherwise all transmitters are backlogged, i.e. we have \emph{saturated} traffic. In that case the time between the generation of each packet is constant and well below the RTT. When we use the term \emph{unsaturated} the time between packets generated by the \code{dummy\_source} is exponentially distributed with $\frac{1}{\lambda}=200ms$. These packets are then buffered in a \code{frame\_buffer}. For single link scenarios this leads to Poisson-distributed traffic.

\paragraph{Measurement and Repetition}
In this thesis \emph{measurement} refers to a period of 500 seconds comprising of five \emph{repetitions} with a duration of 100 seconds each. 

\paragraph{Baseline and Coexistence Measurements}
When referring to the term \emph{baseline} measurement we mean that only one of the two links was active. If both links were active we refer to a \emph{coexistence} measurement. The baseline measurements serve two purposes: confirming that the devices work properly and for comparison with the coexistence measurements. A more detailed description on baseline measurements can be found in Section \ref{sec:quality-standards}.   

\paragraph{Measurement Scenarios}
A scenario is a combination of  MAC protocols employed on the two links as depicted in Table \ref{tab:measurement-scenarios}. We distinguish between two types of scenarios. In "same MAC" scenarios the same MAC protocol is employed on both transmitters. In "different MAC" scenarios different MAC protocols are employed on the transmitters.

\paragraph{Pure ALOHA}
We implement the pure ALOHA protocol based on the theory in Section \ref{sec:aloha} as GNU Radio flowgraph depicted in Figure \ref{fig:grc-aloha-transmitter} and described in Section \ref{sec:aloha-transmitter}.

\paragraph{CSMA/CA}
We implement CSMA/CA based on the theory in Section \ref{sec:csma-ca}. The flowgraph is depicted in Figure \ref{fig:grc-csma-transmitter} with the corresponding description found in Section \ref{sec:csma-transmiter}. We are \textbf{not} featuring the optional IEEE 802.11 RTS/CTS exchange, realize DIFS and SIFS with \code{general\_timers} and the backoff with the \code{backoff} blocks. In two of three measurement variants we set SIFS, DIFS and backoff slot (BO) times to different scaled versions of their values\footnote{The values of DIFS, SIFS and BO in the IEEE 802.11g standard are $\text{DIFS}=50 \,\text{\mu s}$, $\text{SIFS}=10 \,\text{\mu s}$, $\text{BO}=20 \,\text{\mu s}$, $\text{CW}_\text{min}=31$,  $\text{CW}_\text{max}=1023$ \cite{802.11g}.} prescribed in the IEEE 802.11g standard. We refer to these two variants as the high parameter values ($\text{DIFS}=15\,\text{ms}$, $\text{SIFS}=3\,\text{ms}$, $\text{BO}=6\,\text{ms}$) and the low parameter values ($\text{DIFS}=5\,\text{ms}$, $\text{SIFS}=1\,\text{ms}$, $\text{BO}=2\,\text{ms}$). The third variant are the medium parameter values based on the low parameter set but with $\text{DIFS}=9\,\text{ms}$. We employ the same $\text{CW}_\text{min}=31$ and $\text{CW}_\text{max}=1023$ as the IEEE 802.11g standard.

\paragraph{1-persistent CSMA}
For 1-persistent CSMA we use the same flowgraph as for CSMA/CA and set SIFS and backoff slot times to zero. In contrast to theoretical 1-persistent CSMA we sense the channel for DIFS instead of a minimal number of samples. More accurately, we could describe the protocol as "1-persistent CSMA-like with fixed sensing duration", but for brevity's sake we refer to it as 1-persistent CSMA.  
 
\begin{table}[bt]
	\label{tab:measurement-scenarios}
	\begin{center}	
		\begin{tabular}{*{14}{|c}|}
			\hline
				 Scenario Type & Link 1 & Link 2 \\
			\hline
				 & \multicolumn{2}{c|}{ALOHA} \\ 
				Same MAC & \multicolumn{2}{c|}{CSMA/CA (3 variants)} \\
				& \multicolumn{2}{c|}{1-persistent CSMA} \\ 
				\hline
				& ALOHA & CSMA/CA \\
				& unsaturated ALOHA & CSMA/CA \\
				Different MAC & CSMA/CA & CSMA/CA \\
				& 1-persitent CSMA & unsaturated ALOHA \\
				& 1-persistent CSMA & CSMA/CA \\
			\hline
		\end{tabular}\caption{Measurement Scenarios.}
	\end{center}
\end{table}

\section{GNU Radio Flowgraphs}    

A GNU Radio flowgraph is a directed graph, each of whose vertices called blocks implements a certain functionality of the MAC protocol. The edges determine the direction of data flow as discussed in Section \ref{sec:flowgraphs}.

\subsection{Receiver and Sniffer}

%frame_analysis block missing
Figure \ref{fig:grc-receiver} shows the two-way handshake receiving logic. After frame integrity is checked by the \code{frame\_check} block and the type is confirmed to be data frame an acknowledgment is generated by the \code{frame\_type\_check} block. The \code{frame\_probe} blocks record the times when the frames reach certain positions in the flowgraph representing the occurrence of events such as frame reception, passed or failed frame integrity check and more. Note that the address check is disabled so that the receiver may receive frames from any transmitter.

The sniffer (flowgraph in Figure \ref{fig:grc-sniffer}) consists only of a single \code{frame\_probe} block, which records detected power above noise level during the whole measurement. The sniffer provides valuable insight of what is actually going on in the channel from a "neutral" point of view - neutral in the sense of:

\begin{itemize}
	\item A clear distinction between the transmitters can be made according to the received energy levels, since the sniffer is located between the transmitters and transmission gains were chosen accordingly.
	\item Sensing the channel is possible during the whole measurement time, because the sniffer is never sending.
\end{itemize}

In a nutshell, the sniffer is a valuable debugging and verification tool as described in more detail in section \ref{sec:measurement-metrics}.

\begin{sidewaysfigure}[ht]
	\begin{center}
		\subfloat[Receiver]{\includegraphics[width=\textwidth]{pictures/grc_receiver_flowgraph}}
		\label{fig:grc-receiver}
		\vskip 40pt
		\subfloat[Sniffer]{\includegraphics[width=0.3\textwidth]{pictures/grc_sniffer_flowgraph}}
		\label{fig:grc-sniffer}
	\end{center}
	\caption{GRC Receiver Flowgraphs.}
\end{sidewaysfigure}

\subsection{Pure ALOHA Transmitter}
\label{sec:aloha-transmitter}

The flowgraph, whose discussion follows, is depicted in Figure \ref{fig:grc-aloha-transmitter}. The \code{run} block enables us to start several transmitters exactly at the same time, which is useful if we execute the flowgraphs manually without the automated measurement scripts. Payload is generated in the \code{dummy\_source} block, packed into a frame in the \code{framing} block and buffered in the \code{frame\_buffer} block. The interval between generated frames is determined by a \code{general\_timer} block, which we trigger either in constant or exponentially distributed intervals. Self-reception is prevented by shutting down the receiver when about to send a frame through the sending block. As soon as the data packet is sent off the \code{timeout} block receives a copy of the data frame. If the timeout timer is reset by a recevied ACK before it runs out the next frame in the buffer is dequeued, otherwise the data is forwarded to the \code{resend\_check} block. If the maximum number of retransmissions, in our case 6 has not been reached a retransmission is issued, otherwise the frame is dropped without substitution.

\begin{sidewaysfigure}[h]
	\label{fig:grc-aloha-transmitter}
	\begin{center}
		\includegraphics[width=\textwidth]{pictures/grc_aloha_transmitter_flowgraph}
\end{center}
\caption{GRC Pure ALOHA Transmitter Flowgraph.}
\end{sidewaysfigure}

\subsection{CSMA Transmitter}
\label{sec:csma-transmiter}

The CSMA transmitter (Figure \ref{fig:grc-csma-transmitter}) is based on the ALOHA transmitter, but features extra mechanisms as described in section \ref{sec:csma}, which is discussed now. The flowgraph aims at resembling IEEE 802.11 DCF and features CCA through thresholding in the \code{carrier\_sensing} block. Despite the fact that this block has the feature of adaptively determining an appropriate carrier sensing threshold we chose a fixed value of 0.002 power units (PU) \footnote{Power unit is a linear-scale unit read out via the UHD driver.}. This choice was made to make sure that ALOHA transmission power levels were not confused with noise during the adaptive CSMA noise floor detection period. 

DIFS and SIFS are realized through \code{general\_timer} blocks with the respective values. The design, as depicted, does not feature the RTS/CTS exhange.

\begin{sidewaysfigure}[h]
	\label{fig:grc-csma-transmitter}
	\begin{center}
		\includegraphics[width=\textwidth]{pictures/grc_csma_transmitter_flowgraph}
\end{center}
\caption{GRC CSMA Transmitter Flowgraph.}
\end{sidewaysfigure}

\clearpage

\section{Measurement Metrics}
\label{sec:measurement-metrics}

All recorded metrics are defined in this section. Furthermore, we describe how the metrics were obtained and verified. All metrics were originally captured with at least one of the following blocks: \code{frame\_probe}, \code{counter}, \code{number\_recorder} and \code{time\_probe} as depicted in figures \ref{fig:grc-receiver}, \ref{fig:grc-aloha-transmitter} and \ref{fig:grc-csma-transmitter}. In particular, we used the \code{frame\_probe} block to record files with timestamps - and in the case of the sniffer also with energy levels - when frames reach positions in the flowgraph that are associated with certain events, such as data transmission or ACK reception at the transmitter. The \code{counter} block was used to count how often a certain frame was retransmitted and how often the \code{backoff} block was activated. The \code{number\_recorder} was used to capture backoff times and the \code{time\_probe} block to verify frame durations.

\subsection{Throughput}

We define throughput as the mean useful data (payload and headers disregarding retransmissions) transmission rate in the unit kbit/s. We obtain this metric simply by counting the number of ACKs received at the transmitter, multiply it with the frame length of 8 kbits and divide it by the measurement duration. The calculations are done in \code{throughput.py} making use of the CLI tool \code{wc} to count lines. Aggregate and single throughputs are our main metrics to judge a protocol's efficiency or how well a certain combination of protocols can coexist under different conditions, respectively.

\subsection{Round-Trip Time}
\label{sec:rtt}

We define round-trip time (RTT) as the mean time from the buffer dequeuing a data frame until ACK reception. If the variable \code{rtt\_mode} is set to \code{rtt}, then the calculation excludes retransmitted frames. If \code{rtt\_mode} is set to \code{frame\_delay} instead then retransmitted frames are taken into account. How we obtain these metrics is best explained with the code in Listing \ref{lst:rtt}, where \code{ack\_received\_times} and \code{data\_sent\_times} contain the timestamps of the frames. 

\begin{lstlisting}[language=Python, caption={[{Alternative method to calculate RTT and frame delay}](The method used in \code{rtt\_alternative.py} to calculate RTT and frame delay)},label=lst:rtt]
# pointer onto data frame which we use for frame delay calculation
data_pos = 0
for k,ack in enumerate(ack_received_times):
    for l,data in enumerate(data_sent_times):
		# go to 1st data frame that is sent after the respective ack 
        if data > ack:
            if self.rtt_mode == "rtt":
				# the data frame before current position l 
				# must be the frame the ack corresponds to
                rtt += [round(ack - data_sent_times[l-1],5)]
            if self.rtt_mode == "frame_delay":
				# the pointer onto our frame delay reference
				# is used to calculate frame delay
                rtt += [round(ack - data_sent_times[data_pos], 5)]
			# set new reference point for frame delay calculation
            data_pos = l
			# break loop to look at next ack frame!
            break
\end{lstlisting} 

Another way to calculate the RTT is by recording the number of retransmissions of each data frame and subtracting the element with the correct offset in \code{data\_sent\_times} from each ACK reception time. We do not show any code (which can be found in \code{rtt.py}) here, because this has not been used to create any of the plots, although it has been verified to return the same results as the first method. 

\subsection{Packet Loss and Retransmissions per Frame}

Obtaining both metrics involves data processed in \code{rtt.py}, which is why they are calculated there as well. Specifically, we make use of the lists containing the timestamps of ACKs and data frames as well as the number of retransmissions per frame. 
We define packet loss as $ 1 - \frac{n_\text{ACKs}}{n_\text{data}} $, where $ n_\text{ACKs} $ and $ n_\text{data} $ are the number of ACK packets received and data packets sent by the transmitter.
Retransmissions per frame are obtained simply by recording them with a \code{counter} block, which is incremented whenever the \code{timeout} runs out and reset when an ACK is received.

\subsection{Backoff Time}

The script \code{backoff.py} sums up three different backoff times: Firstly, the backoff due to negative CCA, i.e. a busy channel. Secondly, we capture the backoff times after successful transmissions to give other nodes a chance to seize the channel. Lastly, we sum up the two to obtain the total backoff. The total backoff duration reflects the efficiency of the CSMA protocols in dependency on the parameters DIFS, SIFS and backoff slot length \footnote{E.g. for two CSMA transmitter it would be ideal to have both transmitters back off for around 50\% of the transmission time to give each other a chance to transmit.}

\subsection{Packet Durations \& Channel Occupation}

The channel occupation chart as in Figure \ref{fig:results-csma-high-dbl-channel-meta}\subref{fig:results-csma-high-dbl-channel-occupation} provides an approximated logical view on the channel in the fashion of a Gantt chart. Blue patches represent data frames, red patches ACKs and black patches the reception of ACKs. The chart is only a (good) approximation of the channel occupation because the width of the patches are fixed and defined in \code{channel\_occupation.py}. The duration of DATA and ACK frames was previously recorded with the \code{time\_probe} blocks as the difference between the times when the frame was dequeued from the buffer and when it was received by the receiver. As expected, the frame durations were very stable. A data frame took 40 ms to be transmitted and an ACK frame took 7 ms. The variation of frame duration was in the range of 1-2  milliseconds for data frames and in the sub-millisecond range for ACK frames. Depending on the time limits chosen for the plot this may be well below the plot's resolution, which is why the time axis of such plot is limited to a range of a few seconds at most.

\subsection{Channel Energy Level}

The energy levels (measured in a linear-scale, non-negative power unit) over the channel observed by the sniffer (and processed in \code{sniffer.py}) help us to verify a multitude of metrics. We can verify frame durations, round-trip time, backoff time (for saturated traffic) and logical channel occupation\footnote{Frame durations can be verified by reading the time values from the x-axis. RTT and frame delay as per definition in Section \ref{sec:rtt} are obtained in the same way. Theoretically, for saturated traffic, we could add up all times where the energy level is zero to obtain backoff times. Logical channel occupation can easily be derived provided the energy level of each frame type is distinct and known.}. Even collisions are clearly visible and which transmitter caused them. Throughput ratio among transmitters can easily be verified by representing data as CDF, e.g. if two identical MAC protocols run under identical circumstances then we expect a CDF with a step where the height of the "energy columns" to the left and right have equal height, i.e. both transmitters have sent an equal number of data packets.

\section{Measurement Script System}
\label{sec:script-system}

The elaborate script-system was an integral part of the work and enables future users to much more quickly gain results based on automation, since it is no longer necessary to manually execute flowgraphs, manage captured files, run data processing scripts, sync files with github. Instead everything is automatically done for them. The transmission of every frame and data processing step can be traced back with the log files. Furthermore, to accommodate the need for comparison, a retrospective evaluation of any set of measurements \code{belated\_evaluation.py} was created. The user only needs to add a few lines to the script as shown in Listing \ref{lst:belated-evaluation-example}.
  
\begin{lstlisting}[language=Python,caption={[{Retrospective evaluation of measurements}](Evaluation of measurements with \code{belated\_evaluation.py}. In \code{links} we denote the link we used in the corresponding measurement (compare Figure \ref{fig:measurement-setup}).)},label=lst:belated-evaluation-example]
measurement     = [714,715,728,646]
links           = [1,2,1,2]
boxplot_xticks  = [
	"CSMA\nDIFS=15ms\nSIFS=0ms\nBO=0ms\nLink 1\n Coexistence",
    "unsaturated ALOHA\n Link 2\n Coexistence",
    "CSMA\nDIFS=15ms\nSIFS=0ms\nBO=0ms\nLink 1\n Baseline",
    "unsaturated ALOHA\n Link 2\n Baseline"]
\end{lstlisting}

We now discuss in detail how the script system works by reference to Figure \ref{fig:script-system}.
Starting with the user calling \code{measurement\_n.sh}, where n is the ID of the link, general settings are "imported" from \code{measurement\_n.conf}. If the user sets \code{remote\_measurement} to 1 in the conf file then \code{remote\_measurement\_n.sh} synchronizes the files on the remote machine with the github repository, then executes \code{measurement\_n.sh} remotely. Subsequently, \code{measurement.sh} for link n works on open "jobs" from the \code{jobs\_open\_n} directories and optionally puts them into the \code{jobs\_done\_n} directories after completion. In the job files important variables such as duration, repetitions and flowgraph scripts of the measurement are defined. Any variable set in the conf file can be overwritten in the job file since they both are just exporting variables and were separated for semantic reasons only. After the measurement concluded \code{evaluation.py} coordinates data processing which eventually leads to plotting based on Matplotlib as defined in \code{myplot.py}.

\begin{figure}[bt]
	\label{fig:script-system}
	\begin{center}
		\includegraphics[width=0.6\textwidth]{pictures/script_system}
	\end{center}
	\caption{The three phase measurement script system.}
\end{figure}

\section{Quality Norms}
\label{sec:quality-standards}

\paragraph{Statistical Reliability}
As mentioned in Section \ref{sec:measurement-scenarios}, each measurement features five repetitions of 100 seconds duration. Compared to a single measurement of 500 seconds this has the downside that script and hardware initialization (about 1.1 seconds per repetition as can be seen in Figure \ref{fig:qa-channel-energy}) has a negative impact on the accuracy of some metrics, particularly throughput, but was easier to implement as this way five data points are provided in a natural way. The statistical quality could be slightly improved by adding more repetitions and increasing the measurement time. 

\paragraph{Data Processing}
Making use of modularity, multiple sets of test data were created for each data processing script (i.e. metric calculation and plotting scripts), provided to and processed by the script and compared with manually calculated results in a similar fashion as GNU Radio quality assurance tests discussed in \cite{gr-python-tut}. Intermediate data processing steps were printed to the console and logged in the log files where applicable. Additionally, experimental results were checked for plausibility. 

\paragraph{Hardware Functionality}
For each device and protocol variation single link baseline measurements were carried out. Not only can we compare the results of device/protocol combinations to two link scenarios, but also assure that the devices are configured and work correctly. RX/TX gains, when necessary, were tweaked each time the hardware was restarted until no or very little ($\le0.2\%$ mean) packet loss was observable in single links scenarios.
Despite all efforts to find a combination of RX/TX gains and distances between nodes, where no packet loss would occur in single link configurations and at the same time the sniffer detects distinct energy levels for each packet type there still remains some degree of imperfection as depicted in Figure \ref{fig:qa-packet-loss}. This problem of packet loss is generally worse for link 1, because it is farther away from the receiver as is shown in Figure \ref{fig:measurement-setup}.  

\begin{figure}[tb]
	\label{fig:qa-packet-loss}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{pictures/qa_packet_loss}
	\end{center}
	\caption[Quality norm packet loss plot.]{Packet loss plot. We only carry out coexistence measurements, if we have less than 0.2\% mean packet loss in the baseline measurements.}
\end{figure}

\begin{figure}[tb]
	\label{fig:qa-channel-energy}
	\begin{center}
		\subfloat[channel energy ]{\includegraphics[width=0.9\textwidth]{pictures/qa_channel_energy}}
	\end{center}
	\caption[Quality norm channel energy plot.]{Channel energy plot. The first 1.1 seconds of delay in each measurement repetition are caused by hardware initialization and script delays.}
\end{figure}

